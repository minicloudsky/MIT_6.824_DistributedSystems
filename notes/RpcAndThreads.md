## 使用多线程的原因

1. IO 并发
2. 并行化
3. 易用性

### 多线程挑战

共享数据，多线程共享地址空间，共享内存，所有线程都可以读写，更新缓存数据，容易出现bug

共享全局变量 N  在不同的线程之间共享，临界条件，竞争，存在共享状态

n = n+1

对应汇编

load x register

add 1 ,x

store register 

共享数据加锁

只有只有锁时候，这个共享数据才可以使用

Go 调用 lock 来锁住 mutex

## 协作

go channel

condition variable

WaitGroup 启动已知数据的 goroutine，等待事件结束

DeadLock











#  课堂 Q &A

## 异步编程 (事件驱动编程)

单线程+循环等待 input 每次只能执行一个活动

## 多进程和多线程区别

for unix systems

一个进程是一个单独运行的程序，只有一个独立的内存地址空间，在这个进程里面个同时又多个线程

多个进程之间有独立的内存空间 ，在同一个进程中，线程与线程之间可以共享内存，在golang中可以通过 `channel` 进行同步， 但是进程之间无交集

## 当上下文切换时候，是所有线程都在切换吗？

假设只有一个单核CPU，同一时间只能运行一个进程，想在该机器上运行多进程，CPU把时间片进行分割然后反复分配给这两个程序，当硬件时钟到期时候，操作系统把CPU从当前正在运行的进程剥夺，然后分配给另一个进程，这个事件是在进程级别切换的，线程是最终是由操作系统线程所提供的，当操作系统上下文切换时候，就是不同线程之间进行上下文切换时候

## 共享数据加锁

只有持有锁的线程才能访问共享变量

mu..Lock()

n = n+1

mu.UnLock()

## Go 如何知道我们正在锁住哪些变量

go 并不知道，锁和变量之间无关系，对 go 来说是个锁对象，

第一个线程拿到锁。其他线程等到 unlock再执行

## 让锁私有会更好吗

如果有内部数据结构依赖，可能会导致思索和多余的开销

## 内部函数访问定义在外部的变量，外部函数返回后，内部函数变量将指向哪里？

Go 会分析你的内部函数(闭包)，编译器会分配堆内存来存放这个变量，变量不会分配在栈内存上，当外部函数返回时候，对象仍然在堆上，内部函数还是能够访问到，之后GC负责监测变量并进行释放内存操作